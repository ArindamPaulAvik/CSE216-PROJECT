// ======================== COMMENT SYSTEM ========================

// Get comments for a specific episode
app.get('/episode/:episodeId/comments', authenticateToken, async (req, res) => {
  const episodeId = req.params.episodeId;
  const { page = 1, limit = 10 } = req.query;
  const offset = (page - 1) * limit;

  try {
    // Get top-level comments (no parent)
    const [comments] = await pool.query(`
      SELECT 
        c.COMMENT_ID,
        c.TEXT,
        c.TIME,
        c.LIKE_COUNT,
        c.DISLIKE_COUNT,
        c.EDITED,
        c.PINNED,
        c.IMG_LINK,
        u.USER_FIRSTNAME,
        u.USER_LASTNAME,
        u.PROFILE_PICTURE,
        COUNT(replies.COMMENT_ID) as REPLY_COUNT
      FROM COMMENT c
      JOIN USER u ON c.USER_ID = u.USER_ID
      LEFT JOIN COMMENT replies ON c.COMMENT_ID = replies.PARENT_ID AND replies.DELETED = 0
      WHERE c.SHOW_EPISODE_ID = ? 
        AND c.PARENT_ID IS NULL 
        AND c.DELETED = 0
      GROUP BY c.COMMENT_ID
      ORDER BY c.PINNED DESC, c.TIME DESC
      LIMIT ? OFFSET ?
    `, [episodeId, parseInt(limit), offset]);

    // Get total count for pagination
    const [countResult] = await pool.query(`
      SELECT COUNT(*) as total
      FROM COMMENT c
      WHERE c.SHOW_EPISODE_ID = ? 
        AND c.PARENT_ID IS NULL 
        AND c.DELETED = 0
    `, [episodeId]);

    const total = countResult[0].total;
    const totalPages = Math.ceil(total / limit);

    res.json({
      comments,
      pagination: {
        currentPage: parseInt(page),
        totalPages,
        totalComments: total,
        hasMore: page < totalPages
      }
    });
  } catch (err) {
    console.error('Error fetching comments:', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// Get replies for a specific comment
app.get('/comment/:commentId/replies', authenticateToken, async (req, res) => {
  const commentId = req.params.commentId;
  const { page = 1, limit = 5 } = req.query;
  const offset = (page - 1) * limit;

  try {
    const [replies] = await pool.query(`
      SELECT 
        c.COMMENT_ID,
        c.TEXT,
        c.TIME,
        c.LIKE_COUNT,
        c.DISLIKE_COUNT,
        c.EDITED,
        c.IMG_LINK,
        u.USER_FIRSTNAME,
        u.USER_LASTNAME,
        u.PROFILE_PICTURE
      FROM COMMENT c
      JOIN USER u ON c.USER_ID = u.USER_ID
      WHERE c.PARENT_ID = ? 
        AND c.DELETED = 0
      ORDER BY c.TIME ASC
      LIMIT ? OFFSET ?
    `, [commentId, parseInt(limit), offset]);

    // Get total count for pagination
    const [countResult] = await pool.query(`
      SELECT COUNT(*) as total
      FROM COMMENT c
      WHERE c.PARENT_ID = ? 
        AND c.DELETED = 0
    `, [commentId]);

    const total = countResult[0].total;
    const totalPages = Math.ceil(total / limit);

    res.json({
      replies,
      pagination: {
        currentPage: parseInt(page),
        totalPages,
        totalReplies: total,
        hasMore: page < totalPages
      }
    });
  } catch (err) {
    console.error('Error fetching replies:', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// Post a new comment
app.post('/episode/:episodeId/comment', authenticateToken, upload.single('image'), async (req, res) => {
  const episodeId = req.params.episodeId;
  const { text, parentId } = req.body;
  const userEmail = req.user.email;
  const imageFile = req.file ? req.file.filename : null;

  if (!text || text.trim().length === 0) {
    return res.status(400).json({ error: 'Comment text is required' });
  }

  if (text.length > 500) {
    return res.status(400).json({ error: 'Comment text cannot exceed 500 characters' });
  }

  try {
    // Get user ID
    const [userRows] = await pool.query(`
      SELECT U.USER_ID
      FROM PERSON P
      JOIN USER U ON P.PERSON_ID = U.PERSON_ID
      WHERE P.EMAIL = ?
    `, [userEmail]);

    if (userRows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    const userId = userRows[0].USER_ID;

    // Verify episode exists
    const [episodeRows] = await pool.query(
      'SELECT SHOW_EPISODE_ID FROM SHOW_EPISODE WHERE SHOW_EPISODE_ID = ?',
      [episodeId]
    );

    if (episodeRows.length === 0) {
      return res.status(404).json({ error: 'Episode not found' });
    }

    // If replying to a comment, verify parent comment exists
    if (parentId) {
      const [parentRows] = await pool.query(
        'SELECT COMMENT_ID FROM COMMENT WHERE COMMENT_ID = ? AND DELETED = 0',
        [parentId]
      );

      if (parentRows.length === 0) {
        return res.status(404).json({ error: 'Parent comment not found' });
      }
    }

    // Insert comment
    const [result] = await pool.query(`
      INSERT INTO COMMENT (
        USER_ID, 
        SHOW_EPISODE_ID, 
        PARENT_ID, 
        TIME, 
        TEXT, 
        IMG_LINK, 
        LIKE_COUNT, 
        DISLIKE_COUNT, 
        DELETED, 
        EDITED, 
        PINNED
      ) VALUES (?, ?, ?, NOW(), ?, ?, 0, 0, 0, 0, 0)
    `, [userId, episodeId, parentId || null, text.trim(), imageFile]);

    // Get the created comment with user info
    const [newComment] = await pool.query(`
      SELECT 
        c.COMMENT_ID,
        c.TEXT,
        c.TIME,
        c.LIKE_COUNT,
        c.DISLIKE_COUNT,
        c.EDITED,
        c.PINNED,
        c.IMG_LINK,
        u.USER_FIRSTNAME,
        u.USER_LASTNAME,
        u.PROFILE_PICTURE
      FROM COMMENT c
      JOIN USER u ON c.USER_ID = u.USER_ID
      WHERE c.COMMENT_ID = ?
    `, [result.insertId]);

    res.status(201).json({
      message: 'Comment posted successfully',
      comment: newComment[0]
    });
  } catch (err) {
    console.error('Error posting comment:', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// Like/Unlike a comment
app.post('/comment/:commentId/like', authenticateToken, async (req, res) => {
  const commentId = req.params.commentId;
  const userEmail = req.user.email;

  try {
    // Get user ID
    const [userRows] = await pool.query(`
      SELECT U.USER_ID
      FROM PERSON P
      JOIN USER U ON P.PERSON_ID = U.PERSON_ID
      WHERE P.EMAIL = ?
    `, [userEmail]);

    if (userRows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    const userId = userRows[0].USER_ID;

    // Check if comment exists
    const [commentRows] = await pool.query(
      'SELECT COMMENT_ID, LIKE_COUNT FROM COMMENT WHERE COMMENT_ID = ? AND DELETED = 0',
      [commentId]
    );

    if (commentRows.length === 0) {
      return res.status(404).json({ error: 'Comment not found' });
    }

    // Check if user already liked this comment (we'll use a simple approach)
    // In a real app, you'd want a separate COMMENT_LIKES table
    // For now, we'll just increment/decrement the like count
    
    // Simple toggle approach - in production, you'd want to track individual likes
    const [result] = await pool.query(`
      UPDATE COMMENT 
      SET LIKE_COUNT = LIKE_COUNT + 1 
      WHERE COMMENT_ID = ?
    `, [commentId]);

    // Get updated like count
    const [updatedComment] = await pool.query(
      'SELECT LIKE_COUNT FROM COMMENT WHERE COMMENT_ID = ?',
      [commentId]
    );

    res.json({
      message: 'Comment liked successfully',
      likeCount: updatedComment[0].LIKE_COUNT
    });
  } catch (err) {
    console.error('Error liking comment:', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// Dislike a comment
app.post('/comment/:commentId/dislike', authenticateToken, async (req, res) => {
  const commentId = req.params.commentId;
  const userEmail = req.user.email;

  try {
    // Get user ID
    const [userRows] = await pool.query(`
      SELECT U.USER_ID
      FROM PERSON P
      JOIN USER U ON P.PERSON_ID = U.PERSON_ID
      WHERE P.EMAIL = ?
    `, [userEmail]);

    if (userRows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    const userId = userRows[0].USER_ID;

    // Check if comment exists
    const [commentRows] = await pool.query(
      'SELECT COMMENT_ID, DISLIKE_COUNT FROM COMMENT WHERE COMMENT_ID = ? AND DELETED = 0',
      [commentId]
    );

    if (commentRows.length === 0) {
      return res.status(404).json({ error: 'Comment not found' });
    }

    // Simple toggle approach
    const [result] = await pool.query(`
      UPDATE COMMENT 
      SET DISLIKE_COUNT = DISLIKE_COUNT + 1 
      WHERE COMMENT_ID = ?
    `, [commentId]);

    // Get updated dislike count
    const [updatedComment] = await pool.query(
      'SELECT DISLIKE_COUNT FROM COMMENT WHERE COMMENT_ID = ?',
      [commentId]
    );

    res.json({
      message: 'Comment disliked successfully',
      dislikeCount: updatedComment[0].DISLIKE_COUNT
    });
  } catch (err) {
    console.error('Error disliking comment:', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// Edit a comment
app.put('/comment/:commentId', authenticateToken, async (req, res) => {
  const commentId = req.params.commentId;
  const { text } = req.body;
  const userEmail = req.user.email;

  if (!text || text.trim().length === 0) {
    return res.status(400).json({ error: 'Comment text is required' });
  }

  if (text.length > 500) {
    return res.status(400).json({ error: 'Comment text cannot exceed 500 characters' });
  }

  try {
    // Get user ID
    const [userRows] = await pool.query(`
      SELECT U.USER_ID
      FROM PERSON P
      JOIN USER U ON P.PERSON_ID = U.PERSON_ID
      WHERE P.EMAIL = ?
    `, [userEmail]);

    if (userRows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    const userId = userRows[0].USER_ID;

    // Check if comment exists and belongs to user
    const [commentRows] = await pool.query(
      'SELECT COMMENT_ID, USER_ID FROM COMMENT WHERE COMMENT_ID = ? AND DELETED = 0',
      [commentId]
    );

    if (commentRows.length === 0) {
      return res.status(404).json({ error: 'Comment not found' });
    }

    if (commentRows[0].USER_ID !== userId) {
      return res.status(403).json({ error: 'You can only edit your own comments' });
    }

    // Update comment
    await pool.query(`
      UPDATE COMMENT 
      SET TEXT = ?, EDITED = 1 
      WHERE COMMENT_ID = ?
    `, [text.trim(), commentId]);

    // Get updated comment
    const [updatedComment] = await pool.query(`
      SELECT 
        c.COMMENT_ID,
        c.TEXT,
        c.TIME,
        c.LIKE_COUNT,
        c.DISLIKE_COUNT,
        c.EDITED,
        c.PINNED,
        c.IMG_LINK,
        u.USER_FIRSTNAME,
        u.USER_LASTNAME,
        u.PROFILE_PICTURE
      FROM COMMENT c
      JOIN USER u ON c.USER_ID = u.USER_ID
      WHERE c.COMMENT_ID = ?
    `, [commentId]);

    res.json({
      message: 'Comment updated successfully',
      comment: updatedComment[0]
    });
  } catch (err) {
    console.error('Error editing comment:', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// Delete a comment
app.delete('/comment/:commentId', authenticateToken, async (req, res) => {
  const commentId = req.params.commentId;
  const userEmail = req.user.email;

  try {
    // Get user ID
    const [userRows] = await pool.query(`
      SELECT U.USER_ID
      FROM PERSON P
      JOIN USER U ON P.PERSON_ID = U.PERSON_ID
      WHERE P.EMAIL = ?
    `, [userEmail]);

    if (userRows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    const userId = userRows[0].USER_ID;

    // Check if comment exists and belongs to user
    const [commentRows] = await pool.query(
      'SELECT COMMENT_ID, USER_ID FROM COMMENT WHERE COMMENT_ID = ? AND DELETED = 0',
      [commentId]
    );

    if (commentRows.length === 0) {
      return res.status(404).json({ error: 'Comment not found' });
    }

    if (commentRows[0].USER_ID !== userId) {
      return res.status(403).json({ error: 'You can only delete your own comments' });
    }

    // Soft delete comment (mark as deleted instead of actually deleting)
    await pool.query(`
      UPDATE COMMENT 
      SET DELETED = 1, TEXT = '[Comment deleted]'
      WHERE COMMENT_ID = ?
    `, [commentId]);

    res.json({
      message: 'Comment deleted successfully'
    });
  } catch (err) {
    console.error('Error deleting comment:', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// Report a comment
app.post('/comment/:commentId/report', authenticateToken, async (req, res) => {
  const commentId = req.params.commentId;
  const { reportText, violationIds } = req.body;
  const userEmail = req.user.email;

  if (!reportText || reportText.trim().length === 0) {
    return res.status(400).json({ error: 'Report text is required' });
  }

  if (!violationIds || violationIds.length === 0) {
    return res.status(400).json({ error: 'At least one violation type must be selected' });
  }

  try {
    // Get user ID
    const [userRows] = await pool.query(`
      SELECT U.USER_ID
      FROM PERSON P
      JOIN USER U ON P.PERSON_ID = U.PERSON_ID
      WHERE P.EMAIL = ?
    `, [userEmail]);

    if (userRows.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }

    const userId = userRows[0].USER_ID;

    // Check if comment exists
    const [commentRows] = await pool.query(
      'SELECT COMMENT_ID FROM COMMENT WHERE COMMENT_ID = ? AND DELETED = 0',
      [commentId]
    );

    if (commentRows.length === 0) {
      return res.status(404).json({ error: 'Comment not found' });
    }

    // Check if user already reported this comment
    const [existingReport] = await pool.query(
      'SELECT REPORT_ID FROM REPORT WHERE USER_ID = ? AND COMMENT_ID = ?',
      [userId, commentId]
    );

    if (existingReport.length > 0) {
      return res.status(409).json({ error: 'You have already reported this comment' });
    }

    // Insert report
    const [reportResult] = await pool.query(`
      INSERT INTO REPORT (USER_ID, COMMENT_ID, REPORT_TIME, REPORT_TEXT)
      VALUES (?, ?, NOW(), ?)
    `, [userId, commentId, reportText.trim()]);

    const reportId = reportResult.insertId;

    // Insert violation associations
    for (const violationId of violationIds) {
      await pool.query(`
        INSERT INTO REPORT_VIOLATION (REPORT_ID, VIOLATION_ID)
        VALUES (?, ?)
      `, [reportId, violationId]);
    }

    res.status(201).json({
      message: 'Comment reported successfully',
      reportId: reportId
    });
  } catch (err) {
    console.error('Error reporting comment:', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// Get violation types (for reporting)
app.get('/violations', authenticateToken, async (req, res) => {
  try {
    const [violations] = await pool.query('SELECT * FROM VIOLATION ORDER BY VIOLATION_ID');
    res.json(violations);
  } catch (err) {
    console.error('Error fetching violations:', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// Admin: Pin/Unpin a comment
app.post('/comment/:commentId/pin', authenticateToken, async (req, res) => {
  const commentId = req.params.commentId;
  const userEmail = req.user.email;

  try {
    // Check if user is admin (you'll need to implement admin check)
    const [adminRows] = await pool.query(`
      SELECT A.ADMIN_ID
      FROM PERSON P
      JOIN ADMIN A ON P.PERSON_ID = A.PERSON_ID
      WHERE P.EMAIL = ?
    `, [userEmail]);

    if (adminRows.length === 0) {
      return res.status(403).json({ error: 'Admin access required' });
    }

    // Toggle pin status
    const [commentRows] = await pool.query(
      'SELECT PINNED FROM COMMENT WHERE COMMENT_ID = ? AND DELETED = 0',
      [commentId]
    );

    if (commentRows.length === 0) {
      return res.status(404).json({ error: 'Comment not found' });
    }

    const newPinStatus = commentRows[0].PINNED === 1 ? 0 : 1;

    await pool.query(`
      UPDATE COMMENT 
      SET PINNED = ? 
      WHERE COMMENT_ID = ?
    `, [newPinStatus, commentId]);

    res.json({
      message: newPinStatus === 1 ? 'Comment pinned successfully' : 'Comment unpinned successfully',
      pinned: newPinStatus === 1
    });
  } catch (err) {
    console.error('Error pinning/unpinning comment:', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// Get episode info (for comment section)
app.get('/episode/:episodeId', authenticateToken, async (req, res) => {
  const episodeId = req.params.episodeId;

  try {
    const [episode] = await pool.query(`
      SELECT 
        se.SHOW_EPISODE_ID,
        se.SHOW_EPISODE_TITLE,
        se.EPISODE_NUMBER,
        se.SHOW_EPISODE_DESCRIPTION,
        se.SHOW_EPISODE_DURATION,
        se.SHOW_EPISODE_RELEASE_DATE,
        se.VIDEO_URL,
        s.TITLE as SHOW_TITLE,
        s.SHOW_ID
      FROM SHOW_EPISODE se
      JOIN \`SHOW\` s ON se.SHOW_ID = s.SHOW_ID
      WHERE se.SHOW_EPISODE_ID = ?
    `, [episodeId]);

    if (episode.length === 0) {
      return res.status(404).json({ error: 'Episode not found' });
    }

    res.json(episode[0]);
  } catch (err) {
    console.error('Error fetching episode:', err);
    res.status(500).json({ error: 'Database error' });
  }
});

// Get episodes for a show
app.get('/show/:showId/episodes', authenticateToken, async (req, res) => {
  const showId = req.params.showId;

  try {
    const [episodes] = await pool.query(`
      SELECT 
        SHOW_EPISODE_ID,
        EPISODE_NUMBER,
        SHOW_EPISODE_TITLE,
        SHOW_EPISODE_DESCRIPTION,
        SHOW_EPISODE_DURATION,
        SHOW_EPISODE_RELEASE_DATE,
        VIDEO_URL
      FROM SHOW_EPISODE
      WHERE SHOW_ID = ?
      ORDER BY EPISODE_NUMBER ASC
    `, [showId]);

    res.json(episodes);
  } catch (err) {
    console.error('Error fetching episodes:', err);
    res.status(500).json({ error: 'Database error' });
  }
});